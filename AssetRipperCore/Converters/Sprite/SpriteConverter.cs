using AssetRipper.Core.Classes.Meta.Importers.Texture;
using AssetRipper.Core.Classes.SpriteAtlas;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Math;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using System;
using System.Buffers.Binary;

namespace AssetRipper.Core.Converters.Sprite
{
	public static class SpriteConverter
	{
		public static SpriteMetaData GenerateSpriteMetaData(IExportContainer container, SpriteAtlas originAtlas, AssetRipper.Core.Classes.Sprite.Sprite origin)
		{
			origin.GetSpriteCoordinatesInAtlas(originAtlas, out Rectf rect, out Vector2f pivot, out Vector4f border);

			SpriteMetaData instance = new SpriteMetaData(container.ExportVersion);
			instance.Name = origin.Name;
			instance.Rect = rect;
			instance.Alignment = SpriteAlignment.Custom;
			instance.Pivot = pivot;
			instance.Border = border;
			if (SpriteMetaData.HasOutline(container.ExportVersion))
			{
				instance.Outline = origin.GenerateOutline(originAtlas, rect, pivot);
			}
			if (SpriteMetaData.HasPhysicsShape(container.ExportVersion))
			{
				if (AssetRipper.Core.Classes.Sprite.Sprite.HasPhysicsShape(container.Version))
				{
					instance.PhysicsShape = GetPhysicsShape(container, originAtlas, origin, rect, pivot);
				}
			}
			instance.TessellationDetail = 0;
			if (SpriteMetaData.HasBones(container.ExportVersion))
			{
				if (AssetRipper.Core.Classes.Sprite.Sprite.HasBones(container.Version))
				{
					// Scale bones based off of the sprite's PPU
					foreach (AssetRipper.Core.Classes.Sprite.SpriteBone bone in origin.Bones)
					{
						bone.Position *= origin.PixelsToUnits;
						bone.Length *= origin.PixelsToUnits;

						// Set root bone position
						if (bone.ParentId == -1)
						{
							bone.Position.X += origin.Rect.Width / 2;
							bone.Position.Y += origin.Rect.Height / 2;
						}
					}

					instance.Bones = origin.Bones;
					// NOTE: sprite ID is generated by sprite binary content, but we just generate a random value
					instance.SpriteID = Guid.NewGuid().ToString("N");

					instance.Vertices = GetBoneVertices(container, origin);
					instance.Indices = GetBoneIndices(container, origin);

#warning TODO:
					//instance.Edges = GetBoneEdges(container, origin);

					instance.Weights = GetBoneWeights(container, origin);
				}
			}
			return instance;
		}

		private static Vector2f[][] GetPhysicsShape(IExportContainer container, SpriteAtlas originAtlas, AssetRipper.Core.Classes.Sprite.Sprite origin, Rectf rect, Vector2f pivot)
		{
			if (AssetRipper.Core.Classes.Sprite.Sprite.HasPhysicsShape(container.Version))
			{
				return origin.GeneratePhysicsShape(originAtlas, rect, pivot);
			}
			return Array.Empty<Vector2f[]>();
		}

		private static Vector2f[] GetBoneVertices(IExportContainer container, AssetRipper.Core.Classes.Sprite.Sprite origin)
		{
			if (origin.RD.VertexData.Data.Length == 0)
			{
				return Array.Empty<Vector2f>();
			}

			Vector2f[] vertices = new Vector2f[origin.RD.VertexData.VertexCount];
			// Position always comes first
			for (int i = 0, j = 0; i < origin.RD.VertexData.VertexCount; i++,
				j += (int)origin.RD.VertexData.m_Streams[0].Stride)
			{
				vertices[i] = new Vector2f();

				vertices[i].X = BinaryPrimitives.ReadSingleLittleEndian(origin.RD.VertexData.Data.AsSpan(j, 4));
				vertices[i].Y = BinaryPrimitives.ReadSingleLittleEndian(origin.RD.VertexData.Data.AsSpan(j + 4, 4));

				// Scale and translate vertices
				vertices[i] *= origin.PixelsToUnits;

				vertices[i].X += origin.Rect.Width / 2;
				vertices[i].Y += origin.Rect.Height / 2;
			}
			return vertices;
		}

		private static int[] GetBoneIndices(IExportContainer container, AssetRipper.Core.Classes.Sprite.Sprite origin)
		{
			if (origin.RD.IndexBuffer.Length == 0)
			{
				return Array.Empty<int>();
			}

			int[] indices = new int[origin.RD.IndexBuffer.Length / 2];
			for (int i = 0, j = 0; i < origin.RD.IndexBuffer.Length / 2; i++, j += 2)
			{
				indices[i] = BinaryPrimitives.ReadInt16LittleEndian(origin.RD.IndexBuffer.AsSpan(j, 2));
			}
			return indices;
		}

		private static BoneWeights4[] GetBoneWeights(IExportContainer container, AssetRipper.Core.Classes.Sprite.Sprite origin)
		{
			// If the stride is not 40 we know this isn't a valid BoneWeights4 struct
			if (origin.RD.VertexData.VertexCount == 0 || origin.RD.VertexData.m_Streams[1].Stride != 40)
			{
				return Array.Empty<BoneWeights4>();
			}

			BoneWeights4[] weights = new BoneWeights4[origin.RD.VertexData.VertexCount];
			for (int i = 0, j = (int)origin.RD.VertexData.m_Streams[1].Offset; i < origin.RD.VertexData.VertexCount; i++,
				j += (int)origin.RD.VertexData.m_Streams[1].Stride)
			{
				weights[i] = new BoneWeights4();

				weights[i].Weight0 = BinaryPrimitives.ReadSingleLittleEndian(origin.RD.VertexData.Data.AsSpan(j + 8, 4));
				weights[i].Weight1 = BinaryPrimitives.ReadSingleLittleEndian(origin.RD.VertexData.Data.AsSpan(j + 12, 4));
				weights[i].Weight2 = BinaryPrimitives.ReadSingleLittleEndian(origin.RD.VertexData.Data.AsSpan(j + 16, 4));
				weights[i].Weight3 = BinaryPrimitives.ReadSingleLittleEndian(origin.RD.VertexData.Data.AsSpan(j + 20, 4));

				weights[i].BoneIndex0 = BinaryPrimitives.ReadInt32LittleEndian(origin.RD.VertexData.Data.AsSpan(j + 24, 4));
				weights[i].BoneIndex1 = BinaryPrimitives.ReadInt32LittleEndian(origin.RD.VertexData.Data.AsSpan(j + 28, 4));
				weights[i].BoneIndex2 = BinaryPrimitives.ReadInt32LittleEndian(origin.RD.VertexData.Data.AsSpan(j + 32, 4));
				weights[i].BoneIndex3 = BinaryPrimitives.ReadInt32LittleEndian(origin.RD.VertexData.Data.AsSpan(j + 36, 4));
			}
			return weights;
		}
	}
}
