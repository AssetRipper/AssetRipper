using AssetRipper.Core.Classes.Meta.Importers.Texture;
using AssetRipper.Core.Classes.SpriteAtlas;
using AssetRipper.Core.Math;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using System;

namespace AssetRipper.Core.Converters.Sprite
{
	public static class SpriteConverter
	{
		public static SpriteMetaData GenerateSpriteMetaData(IExportContainer container, SpriteAtlas originAtlas, AssetRipper.Core.Classes.Sprite.Sprite origin)
		{
			origin.GetSpriteCoordinatesInAtlas(originAtlas, out Rectf rect, out Vector2f pivot, out Vector4f border);

			SpriteMetaData instance = new SpriteMetaData(container.ExportVersion);
			instance.Name = origin.Name;
			instance.Rect = rect;
			instance.Alignment = SpriteAlignment.Custom;
			instance.Pivot = pivot;
			instance.Border = border;
			if (SpriteMetaData.HasOutline(container.ExportVersion))
			{
				instance.Outline = origin.GenerateOutline(originAtlas, rect, pivot);
			}
			if (SpriteMetaData.HasPhysicsShape(container.ExportVersion))
			{
				if (AssetRipper.Core.Classes.Sprite.Sprite.HasPhysicsShape(container.Version))
				{
					instance.PhysicsShape = GetPhysicsShape(container, originAtlas, origin, rect, pivot);
				}
			}
			instance.TessellationDetail = 0;
			if (SpriteMetaData.HasBones(container.ExportVersion))
			{
				if (AssetRipper.Core.Classes.Sprite.Sprite.HasBones(container.Version))
				{
					// Scale bones based off of the sprite's PPU
					foreach (AssetRipper.Core.Classes.Sprite.SpriteBone bone in origin.Bones)
					{
						bone.Position *= origin.PixelsToUnits;
						bone.Length *= origin.PixelsToUnits;

						// Set root bone position
						if (bone.ParentId == -1)
						{
							bone.Position.X += origin.Rect.Width / 2;
							bone.Position.Y += origin.Rect.Height / 2;
						}
					}

					instance.Bones = origin.Bones;
					// NOTE: sprite ID is generated by sprite binary content, but we just generate a random value
					instance.SpriteID = Guid.NewGuid().ToString("N");
#warning TODO:
					/*instance.Vertices = GetBoneVertices(container, origin);
					instance.Indices = GetBoneIndices(container, origin);
					instance.Edges = GetBoneEdges(container, origin);
					instance.Weights = GetBoneWeights(container, origin);*/
				}
			}
			return instance;
		}

		private static Vector2f[][] GetPhysicsShape(IExportContainer container, SpriteAtlas originAtlas, AssetRipper.Core.Classes.Sprite.Sprite origin, Rectf rect, Vector2f pivot)
		{
			if (AssetRipper.Core.Classes.Sprite.Sprite.HasPhysicsShape(container.Version))
			{
				return origin.GeneratePhysicsShape(originAtlas, rect, pivot);
			}
			return Array.Empty<Vector2f[]>();
		}

		private static int[] GetBoneIndices(IExportContainer container, AssetRipper.Core.Classes.Sprite.Sprite origin)
		{
			if (origin.RD.IndexBuffer.Length == 0)
			{
				return Array.Empty<int>();
			}

			int[] indices = new int[origin.RD.IndexBuffer.Length / 2];
			for (int i = 0, j = 0; i < origin.RD.IndexBuffer.Length; i++, j += 2)
			{
				indices[i] = BitConverter.ToUInt16(origin.RD.IndexBuffer, j);
			}
			return indices;
		}
	}
}
