using AssetRipper.Core.Classes.Meta.Importers.Texture;
using AssetRipper.Core.Classes.SpriteAtlas;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Mesh;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Math;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using System;
using System.Buffers.Binary;

namespace AssetRipper.Core.Converters.Sprite
{
	public static class SpriteConverter
	{
		public static SpriteMetaData GenerateSpriteMetaData(IExportContainer container, SpriteAtlas originAtlas, AssetRipper.Core.Classes.Sprite.Sprite origin)
		{
			origin.GetSpriteCoordinatesInAtlas(originAtlas, out Rectf rect, out Vector2f pivot, out Vector4f border);

			SpriteMetaData instance = new SpriteMetaData(container.ExportVersion);
			instance.Name = origin.Name;
			instance.Rect = rect;
			instance.Alignment = SpriteAlignment.Custom;
			instance.Pivot = pivot;
			instance.Border = border;
			if (SpriteMetaData.HasOutline(container.ExportVersion))
			{
				instance.Outline = origin.GenerateOutline(originAtlas, rect, pivot);
			}
			if (SpriteMetaData.HasPhysicsShape(container.ExportVersion))
			{
				if (AssetRipper.Core.Classes.Sprite.Sprite.HasPhysicsShape(container.Version))
				{
					instance.PhysicsShape = GetPhysicsShape(container, originAtlas, origin, rect, pivot);
				}
			}
			instance.TessellationDetail = 0;
			if (SpriteMetaData.HasBones(container.ExportVersion))
			{
				if (AssetRipper.Core.Classes.Sprite.Sprite.HasBones(container.Version))
				{
					// Scale bones based off of the sprite's PPU
					foreach (AssetRipper.Core.Classes.Sprite.SpriteBone bone in origin.Bones)
					{
						bone.Position *= origin.PixelsToUnits;
						bone.Length *= origin.PixelsToUnits;

						// Set root bone position
						if (bone.ParentId == -1)
						{
							bone.Position.X += origin.Rect.Width / 2;
							bone.Position.Y += origin.Rect.Height / 2;
						}
					}

					instance.Bones = origin.Bones;
					// NOTE: sprite ID is generated by sprite binary content, but we just generate a random value
					instance.SpriteID = Guid.NewGuid().ToString("N");

					GetBoneGeometry(container, instance, origin);
				}
			}
			return instance;
		}

		private static Vector2f[][] GetPhysicsShape(IExportContainer container, SpriteAtlas originAtlas, AssetRipper.Core.Classes.Sprite.Sprite origin, Rectf rect, Vector2f pivot)
		{
			if (AssetRipper.Core.Classes.Sprite.Sprite.HasPhysicsShape(container.Version))
			{
				return origin.GeneratePhysicsShape(originAtlas, rect, pivot);
			}
			return Array.Empty<Vector2f[]>();
		}

		private static void GetBoneGeometry(IExportContainer container, SpriteMetaData instance, AssetRipper.Core.Classes.Sprite.Sprite origin)
		{
			origin.RD.VertexData.ReadData(container.Version,
				out int vertexCount,
				out Vector3f[] vertices,
				out Vector3f[] normals,
				out Vector4f[] tangents,
				out ColorRGBA32[] colors,
				out BoneWeights4[] skin,
				out Vector2f[] uv0,
				out Vector2f[] uv1,
				out Vector2f[] uv2,
				out Vector2f[] uv3,
				out Vector2f[] uv4,
				out Vector2f[] uv5,
				out Vector2f[] uv6,
				out Vector2f[] uv7);

			// Convert Vector3f into Vector2f
			Vector2f[] verts = vertexCount == 0 ? Array.Empty<Vector2f>() : new Vector2f[vertexCount];
			for (int i = 0; i < vertexCount; i++)
			{
				verts[i] = new Vector2f();

				verts[i].X = vertices[i].X;
				verts[i].Y = vertices[i].Y;

				// Scale and translate vertices properly
				verts[i] *= origin.PixelsToUnits;

				verts[i].X += origin.Rect.Width / 2;
				verts[i].Y += origin.Rect.Height / 2;
			}

			instance.Vertices = verts;

			if (origin.RD.IndexBuffer.Length == 0)
			{
				instance.Indices = Array.Empty<int>();
			}
			else
			{
				instance.Indices = new int[origin.RD.IndexBuffer.Length / 2];
				for (int i = 0, j = 0; i < origin.RD.IndexBuffer.Length / 2; i++, j += 2)
				{
					instance.Indices[i] = BinaryPrimitives.ReadInt16LittleEndian(origin.RD.IndexBuffer.AsSpan(j, 2));
				}
			}

#warning TODO: SpriteConverter does not generate instance.Edges

			instance.Weights = skin == null ? Array.Empty<BoneWeights4>() : skin;
		}
	}
}
